\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{color}
\usepackage{multicol}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage[margin=1.75cm]{geometry}
\usepackage[theorems]{tcolorbox} % for producing coloured boxes
\tcbuselibrary{theorems} % theorems with tcolorbox

% Reduce spacing
\usepackage{enumitem}
\setlist{nosep} % Remove space around list items
\usepackage{titlesec}
\titlespacing{\section}{0pt}{1ex plus 1ex minus .2ex}{0.5ex plus .2ex}
\titlespacing{\subsection}{0pt}{0.75ex plus 1ex minus .2ex}{0.5ex plus .2ex}

% Define colors for code listing
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{codemagenta}{rgb}{0.75, 0.0, 0.35}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Code listing style
\lstdefinestyle{mystyle}{
    language=Python,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{codemagenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}
\newtcbox{\code}{on line, boxrule=0pt, boxsep=0pt, top=2pt, left=2pt, bottom=2pt, right=2pt, colback=gray!15, colframe=white, fontupper={\ttfamily \footnotesize}}

\hypersetup{
    pdftitle={Python Exam Cheatsheet}
}

\title{Python Exam Cheatsheet --- 20606}
\author{Anastasia Zarankin \& Yehonatan Simian}
\date{}

\pagestyle{empty} % Suppress page numbers

\begin{document}

\maketitle
\thispagestyle{empty} % Suppress page numbers

\section{Instructions}
\begin{multicols}{2}
\subsection{Staff Letter}
\begin{itemize}
  \item All code must be well documented.
  \item Begin algorithms with a brief explanation.
  \item Algorithms must be as efficient as possible.
  \item Allowed functions are described in~\cref{sec:allowed-functions}.
\end{itemize}

\subsection{Forum Instructions}
\begin{itemize}
  \item Helper functions may be defined nestedly.
  \item A Sliced list is not considered as a new list.
  \item \code{in} is considered $O(1)$ (constant time).
  \item \code{min}, \code{max} on a list are considered $O(n)$.
\end{itemize}
\end{multicols}

\subsection{Allowed Functions}\label{sec:allowed-functions}

\subsubsection{Built-in Functions}
\vspace{-0.6cm}
\begin{multicols}{4}
  \begin{itemize}
      \item abs
      \item float
      \item input
      \item int
      \item isinstance
      \item len
      \item list
      \item max
      \item min
      \item pow
      \item print
      \item range
      \item sorted
      \item str
      \item sum
      \item tuple
  \end{itemize}
\end{multicols}
\vspace{-0.7cm}
\begin{multicols}{2}
\begin{lstlisting}
abs(-5)              # = 5
float(5)             # = 5.0
int("5")             # = 5
isinstance(5, int)   # = True
len("Hello")         # = 5
list("Bye")          # = ['B', 'y', 'e']
max(1, 5, 3)         # = 5
\end{lstlisting}
\begin{lstlisting}
min(1, 5, 3)      # = 1
pow(2, 3)         # = 8
list(range(5))    # = [0, 1, 2, 3, 4]
sorted([3, 1, 2]) # = [1, 2, 3]
str(5)            # = '5'
sum([1, 2, 3])    # = 6
tuple([1, 2, 3])  # = (1, 2, 3)
\end{lstlisting}
\end{multicols}
\vspace{-0.8cm}
\begin{lstlisting}
user_input = input("Enter something: ")  # Waits for user input (String)
\end{lstlisting}

\subsubsection{String Methods}
\vspace{-0.6cm}
\begin{multicols}{4}
  \begin{itemize}
      \item slicing
      \item in
      \item +
  \end{itemize}
\end{multicols}
\vspace{-0.4cm}
\begin{lstlisting}
  s = "Hello"
  print(s[1:-1:2])       # Output: 'el'
  print("Hell" in s)     # Output: True
  print(s + ", Goodbye") # Output: 'Hello, Goodbye'
\end{lstlisting}

\subsubsection{List Methods}
\vspace{-0.6cm}
\begin{multicols}{4}
  \begin{itemize}
      \item slicing
      \item in
      \item +
      \item sort
      \item pop
      \item copy
      \item append
  \end{itemize}
\end{multicols}
\vspace{-0.4cm}
\begin{lstlisting}
  l1 = [1, 2.0, "3"]
  l2 = [9, 2.0]
  print(l1[1:-1:2])  # Output: [2.0]
  print(2 in l1)     # Output: True
  print(l1 + l2)     # Output: [1, 2.0, '3', 9, 2.0]
  l2.sort()          # l2 is now [2.0, 9]
  l1.sort()          # TypeError: '<' not supported...
  l1.pop()           # l1 is now [1, 2.0]
  l1.sort()          # l1 is now [1, 2.0]
  l3 = l1.copy()     # l3 is now [1, 2.0]
  l1.append('hi')    # l1 is now [1, 2.0, 'hi']
\end{lstlisting}

\pagebreak

\section{Exceptions}

\begin{lstlisting}
def handle_exception():
  try:
    # Code that may raise an exception
  except ExceptionType as e:
    # Handle the exception, e.g., print(e)
  except (ExceptionType1, ExceptionType2) as e:
    # Handle multiple exceptions
  except:
    # Handle all other exceptions
  else:
    # Code that runs if no exception was raised
  finally:
    # Code that always runs
\end{lstlisting}

\section{Useful Functions}

\begin{multicols}{2}
\begin{lstlisting}
def index_of(num, lst):
  if not lst:
    return -1
  if lst[0] == num:
    return 0
  index = index_of(num, lst[1:])
  if index != -1:
    index += 1
  return index
\end{lstlisting}

\begin{lstlisting}
def is_sorted(lst):
  if len(lst) <= 1:
    return True
  if lst[0] > lst[1]:
    return False
  return is_sorted(lst[1:])
\end{lstlisting}

\begin{lstlisting}
def is_palindrome(s):
  if len(s) <= 1:
    return True
  if s[0] != s[-1]:
    return False
  return is_palindrome(s[1:-1])
\end{lstlisting}

\begin{lstlisting}
def is_power_of_2(n):
  if n == 1:
    return True
  if n % 2 != 0 or n == 0:
    return False
  return is_power_of_2(n // 2)
\end{lstlisting}

\begin{lstlisting}
def is_prime(n, i=2):
  if n <= 2:
    return n == 2
  if n % i == 0:
    return False
  if i * i > n:
    return True
      
  return is_prime(n, i + 1)
\end{lstlisting}

\begin{lstlisting}
def exist(num, lst):
  if not lst:
      return False
  if lst[0] == num:
      return True
  return exist(num, lst[1:])
\end{lstlisting}

\begin{lstlisting}
def is_square(mat):
  if len(mat) == 0:
      return False
  for row in mat:
      if len(row) != len(mat):
          return False
  return True
\end{lstlisting}

\begin{lstlisting}
def bubble_sort(lst):
  for i in range(len(lst)):
    for j in range(len(lst) - 1):
      if lst[j] > lst[j+1]:
        lst[j], lst[j+1] = lst[j+1], lst[j]
  return lst
\end{lstlisting}
\end{multicols}
\vspace{-0.5cm}
\begin{lstlisting}
def max_sort(lst):
  if len(lst) == 1:
    return lst
  max_index = index_of(max(lst), lst)
  lst[max_index], lst[-1] = lst[-1], lst[max_index]
  return max_sort(lst[:-1]) + [lst[-1]]
\end{lstlisting}

\pagebreak

\section{Preparation Exercises}\label{sec:preparation-exercises}
\begin{lstlisting}
def maximal_drop(lst):
  # Calculate the maximal drop between two heights in a list.
  if not lst:
    return 0

  max_drop = 0
  max_height_so_far = lst[0]

  for height in lst:
    if height > max_height_so_far:
      max_height_so_far = height
    else:
      drop = max_height_so_far - height
      if drop > max_drop:
        max_drop = drop

  return max_drop
\end{lstlisting}

\begin{lstlisting}
def is_serpertine(mat):
  if not is_square(mat) or mat[0][0] != 1:
      return False

  n = len(mat)
  for i in range(n):
    for j in range(1, n):
      if i % 2 == 0 and not mat[i][j] - mat[i][j - 1] == 1: 
        return False # Check ascending order for even rows
      elif i % 2 == 1 and not mat[i][j - 1] - mat[i][j] == 1:  
        return False # Check descending order for odd rows

  return True
\end{lstlisting}

\begin{lstlisting}
def is_identity(mat, x, size):
  if not is_square(mat) or x < 0 or x + size > len(mat) or size < 1:
    return False

  for i in range(size):
    for j in range(size):
      if (i == j and mat[x + i][x + j] != 1) or (
          i != j and mat[x + i][x + j] != 0
      ):
        return False

  return True
\end{lstlisting}

\begin{lstlisting}
def bulls_and_cows(number, guess):
  def helper(number, guess, guess_index):
      if guess_index >= len(guess):
          return 0
      number_index = index_of(guess[guess_index], number)
      points = 0
      if number_index != -1:
          points += 1
      if number_index == guess_index:
          points += 1
      return points + helper(number, guess, guess_index + 1)

  return helper(number, guess, 0)
\end{lstlisting}

\newgeometry{top=1cm, bottom=1cm, left=1.75cm, right=1.75cm}
  
\begin{multicols}{2}
\begin{lstlisting}
def find_pair(sum, lst):
  # Check if there are two numbers in the list that sum up to `sum`.
  if not lst:
    return False
  if exist(sum - lst[0], lst[1:]):
    return True

  return find_pair(sum, lst[1:])
\end{lstlisting}
\begin{lstlisting}
def max_matrix(mat):
  # Maximum size of an identity central submatrix of square and odd sized `mat`.
  n = len(mat)
  for x in range(n // 2 + 1):
    size = n - x * 2
    if is_identity(mat, x, size):
      return size
  return 0
\end{lstlisting}
\end{multicols}

\vspace{-0.85cm}

\begin{multicols}{2}
\begin{lstlisting}
def minus_plus(lst):
  # Check if each num has a negative twin.
  if len(lst) % 2 != 0:
    return False

  def helper(sublist):
    if not sublist:
      return True
    twin = exist(-sublist[0], lst)
    return twin and helper(sublist[1:])

  return helper(lst)
\end{lstlisting}
\begin{lstlisting}
def secret(s1, s2, key):
  # Check if s2 is derived from the s1.
  if len(s1) != len(s2):
    return False
  def helper(index):
    if index == len(s1):
      return True
    c = ord(s1[index]) + key + index
    if c != ord(s2[index]):
      return False
    return helper(index + 1)
  return helper(0)
\end{lstlisting}
\end{multicols}

\vspace{-0.85cm}

\begin{multicols}{2}
\begin{lstlisting}
def max_mul2(lst):
  # Find the largest possible product of two elements in a list.
  max1 = max2 = float("-inf")
  min1 = min2 = float("inf")
  for num in lst:
    # Update the two largest values
    if num > max1:
      max2 = max1
      max1 = num
    elif num > max2:
      max2 = num
    # Update the two smallest values
    if num < min1:
      min2 = min1
      min1 = num
    elif num < min2:
      min2 = num
  return max(max1 * max2, min1 * min2)
\end{lstlisting}
\begin{lstlisting}
def print_pairs(arr, k):
  # Print all pairs in the list whose difference is exactly k.
  n = len(arr)
  if n < 2:
    return
  left, right = 0, 1
  while right < n:
    diff = arr[right] - arr[left]
    if diff == k:
      print(f"({arr[left]}, {arr[right]})")
      left += 1
      right += 1
    elif diff > k:
      left += 1
      if left == right:
        right += 1
    else:
      right += 1
\end{lstlisting}
\end{multicols}

\subsection{Exercise 10: Coffee Shop}\label{subsec:exercise-10}
\begin{lstlisting}
class Date:
  def __init__(self, d, m, y):
    self._day = d
    self._month = m
    self._year = y

  def __eq__(self, other):
    return (isinstance(other, Date)
            and self._year == other._year
            and self._month == other._month
            and self._day == other._day)

  def __lt__(self, other):
    if not isinstance(other, Date):
      return False
    if self._year != other._year:
      return self._year < other._year
    if self._month != other._month:
      return self._month < other._month
    return self._day < other._day
\end{lstlisting}

\pagebreak

\begin{lstlisting}
class Order:
  _order_num = 1

  def __init__(self, day, month, year, hour, minute, cost=50):
    self._t = Time(hour, minute)
    self._d = Date(day, month, year)
    self._cost = cost
    self._order_id = Order._order_num
    Order._order_num += 1

  def __gt__(self, other):
    return isinstance(other, Order) and self._cost > other._cost
\end{lstlisting}

\begin{lstlisting}
class CashRegister:
  def __init__(self):
    self._orders = []

  def add_order(self, order):
    self._orders.append(order)

  def monthly_total_income(self, month):
    return sum([order._cost for order in self._orders if order._d._month == month])

  def most_expensive_order(self, date):
    return max([order for order in self._orders if order._d == date])._order_id

  def less_than(self, cost):
    filtered_orders = [order for order in self._orders if order._cost < cost]
    return filtered_orders if filtered_orders else None
\end{lstlisting}

\subsection{Exercise 11: Contacts List}\label{subsec:exercise-11}

\begin{lstlisting}
class Person:
  def __init__(self, name, id, birth):
    self._name = name
    self._id = id
    self._birth = birth

  def __eq__(self, other):
    return isinstance(other, Person) and self._id == other._id
\end{lstlisting}

\begin{lstlisting}
class ContactsList:
  def __init__(self) -> None:
    self._contacts = []

  def born_in_date(self, d):
    return [contact for contact in self._contacts if contact._birth == d]

  def oldest_contact(self):
    def get_birth(contact):
      return contact._birth

    return min(self._contacts, key=get_birth)

  def born_in_month(self):
    months = [0] * 13
    for contact in self._contacts:
      months[contact._birth._month] += 1
    return [(i, months[i]) for i in range(1, 13)]
\end{lstlisting}

\section{Maman 13}
\noindent Note:
\begin{itemize}
  \item Maman 11 is \code{bulls\_and\_cows} that's implemented in~\cref{sec:preparation-exercises}.
  \item Maman 12 is \code{tic\_tac\_toe} and I highly doubt that such thing will be on the exam.
  \item Maman 14 is just classes, nothing that's not covered on~\cref{subsec:exercise-10} and~\cref{subsec:exercise-11}.
\end{itemize}

\begin{lstlisting}
def find_missing_item_linear(lst):
  # Find the only missing number in an arithmetic sequence of at least four numbers
  diffs = []
  for i in range(3):
    diff = lst[i + 1] - lst[i]
    if diff in (diffs):
      correct_diff = diff
        break
    diffs.append(diff)
      
  correct_diff = (lst[-1] - lst[0]) // len(lst)
  for i in range(len(lst) - 1):
    if lst[i + 1] - lst[i] != correct_diff:
      return lst[i] + correct_diff
\end{lstlisting}

\begin{lstlisting}
def find_missing_item_logarithmic(lst): # Same as above but logarithmic.
  diffs = ... # same as lines 3-9 in the previous function

  left, right = 0, len(lst) - 1
  while left <= right: # Find the missing number using binary search
    mid = (left + right) // 2
    expected = lst[0] + mid * correct_diff  # a_n=a_1+(n-1)*d
    if lst[mid] != expected:
      if lst[mid - 1] == lst[0] + (mid - 1) * correct_diff:
        return expected
      right = mid - 1
    else:
      left = mid + 1
\end{lstlisting}

\begin{lstlisting}
def split_list_index(lst):
  # Find the index to split a list into two parts with equal sums.
  if len(lst) < 2:
    return -1
  total_sum, left_sum = sum(lst), 0
  for i in range(len(lst)):
    left_sum += lst[i]
    total_sum -= lst[i]
    if left_sum == total_sum:
      return i
  return -1
\end{lstlisting}

\begin{lstlisting}
def max_sequence(lst, prev_last_digit=None, current_length=0, max_length=0):
  # Return the length of the longest sequence of numbers with the same first and last digits. Assume that `lst` is not empty and contains only integers.
  if not lst:
    return max_length
  first, *rest = lst
  first_last_digit, first_first_digit  = first % 10, int(str(first)[0])
  if prev_last_digit is None or prev_last_digit == first_first_digit:
    current_length += 1
    max_length = max(max_length, current_length)
  else:
    current_length = 1
  return max_sequence(rest, first_last_digit, current_length, max_length)
\end{lstlisting}

\begin{lstlisting}
def order(str1, str2):
  # Merge two ordered strings into one ordered string. Assume that the strings contain only lowercase letters, are ordered in ascending order, and may have different lengths.
  if not str1:
    return str2
  if not str2:
    return str1
  if str1[0] < str2[0]:
    return str1[0] + order(str1[1:], str2)
  return str2[0] + order(str1, str2[1:])
\end{lstlisting}

\restoregeometry{}

\section{Exam 26.06.2020}

\subsection{Question 1}
\begin{lstlisting}
def biggest_sum(lst):
  # Return the biggest sum of integers between 2 zeroes in `lst`.
  max_sum, curr_sum = 0, 0

  for num in lst[index_of(0, lst) + 1 :]:
      if num == 0:
          max_sum = max(max_sum, curr_sum)
          curr_sum = 0
      else:
          curr_sum += num

  return max_sum
\end{lstlisting}

\begin{lstlisting}
def biggest_sum_row(mat):
  # Return the index of the row with the biggest_sum.
  if not mat:
      return None

  max_sum, max_index = 0, 0

  for i in range(len(mat)):
      curr_sum = biggest_sum(mat[i])
      if curr_sum > max_sum:
          max_sum = curr_sum
          max_index = i

  return max_index
\end{lstlisting}

\subsection{Question 2}
\begin{lstlisting}
def common(lst1, lst2):
  # Return the common elements of both lists.
  commons_lst = []
  i, j = 0, 0
  while i < len(lst1) and j < len(lst2):
      if lst1[i] == lst2[j]:
          commons_lst.append(lst1[i])
          i += 1
          j += 1
      elif lst1[i] > lst2[j]:
          j += 1
      else:
          i += 1

  return commons_lst or None
\end{lstlisting}

\subsection{Question 3}
\begin{lstlisting}
def max_pos_seq(lst):
  # Return the number of highest sequence of consecutive positive numbers in `lst`.

  def helper(lst, curr_seq):
      if not lst:
          return curr_seq
      if lst[0] <= 0:
          return max(curr_seq, helper(lst[1:], 0))
      return helper(lst[1:], curr_seq + 1)

  return helper(lst, 0)
\end{lstlisting}

\begin{lstlisting}
def is_palindrome(lst):
  # Return whether all elements, as well as the list itself, are palindromes.
  if not lst:
      return True

  begin, end = lst[0], lst[-1]

  return begin == end == begin[::-1] and is_palindrome(lst[1:-1])
\end{lstlisting}

\subsection{Question 4}
\noindent Question 4 is boring and nothing that's not covered on~\cref{subsec:exercise-10} and~\cref{subsec:exercise-11}.

\subsection{Question 5}
\begin{lstlisting}
def mirror_list(mat):
  # Check if the matrix is a mirror list with minimum comparisons.
  # Note: I'm not sure if this is the best solution.
  if not mat or not mat[0]:
      return False

  def check_equality_2(el1, el2):
      if not isinstance(el1, str) or not isinstance(el2, str):
          raise TypeError("The matrix must contain only strings")
      if len(el1) != 1 or len(el2) != 1:
          raise ValueError("The matrix must contain only single characters")
      return el1 == el2

  def check_equality_4(el1, el2, el3, el4):
      return check_equality_2(el1, el2) and check_equality_2(el3, el4) and el2 == el3

  mid_x = len(mat) // 2
  mid_y = len(mat[0]) // 2
  for i in range(mid_x):
      for j in range(mid_y):
          if not check_equality_4(mat[i][j], mat[i][~j], mat[~i][j], mat[~i][~j]):
              return False

  if len(mat) % 2 == 1:
      for i in range(mid_x + 1):
          if not check_equality_2(mat[mid_x][i], mat[mid_x][~i]):
              return False

  if len(mat[0]) % 2 == 1:
      for j in range(mid_y + 1):
          if not check_equality_2(mat[j][mid_y], mat[~j][mid_y]):
              return False

  return True
\end{lstlisting}

\section{Yo Mama Jokes}
\noindent I have some space left, so here are some Yo Mama jokes generated by GitHub Copilot:
\begin{itemize}
  \item Yo mama is so fat, when she wears a yellow raincoat, people yell, ``Taxi!''
  \item Yo mama is so stupid, she put two quarters in her ears and thought she was listening to 50 Cent.
  \item Yo mama is so old, when she was in school, history was called current events.
  \item Yo mama is so short, you can see her feet on her driver's license.
  \item Yo mama is so ugly, when she walks into a bank, they turn off the cameras.
  \item Yo mama is so poor, she walked down the road with one shoe. And if you ask her if she lost a shoe, she'd say ``No, I found one.''
\end{itemize}
Thank you.

\end{document}